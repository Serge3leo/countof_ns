<!-- vim:set sw=4 ts=8 fileencoding=utf8:
 SPDX-License-Identifier: BSD-2-Clause
 SPDX-FileCopyrightText: 2026 Сергей Леонтьев (leo@sai.msu.ru)
 -->

# Долгожданный оператор `_Countof`

Как заметил Алексей Годин, даже полвека ещё не прошло и, наконец, дождались. В проекте стандарта языка C2y появился оператор числа элементов.
## Оператор `_Countof`
Оператор `_Countof` применятся к выражению, имеющему полностью определённый тип массива, или к имени такого типа, заключенному в круглые скобки.

Оператор `_Countof` возвращает количество элементов в своем операнде. Количество элементов определяется типом операнда. Результатом является целое число. Если количество элементов типа массива является переменным, операнд вычисляется, в противном случае операнд не вычисляется, а выражение является целым константным выражением.

В заголовочном файле `<stdcountof.h>` определяется макрос `countof`, который определяется как `_Countof`.
### Этимология названия
В первоначальном предложении [N3369: The `_Lengthof` Operator](https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3369.pdf), предлагалось дать этому оператору имя: `_Lengthof` (правда, после ряда метаний по кругу `_Lengthof => elementsof => nelementsof => neltsof => _Lengthof`). Однако, результаты опроса [N3469: Big Array Size Survey](https://www.open-std.org/JTC1/SC22/WG14/www/docs/n3469.htm):
![[big_array_size_survey_map.png]]
убедительно показали, что наиболее предпочтительные варианты, либо просто `countof`, либо  `_Countof` с заголовочным файлом `<stdcountof.h>` и макросом `countof`, который и вошёл в проект C2y.

К сожалению, распределение голосов по странам и языкам дано только в виде картинки.
### Реализация
На настоящий момент (январь 2026), оператор `_Countof` реализован:
1. Clang версии 21;
2. GNU gcc версии 16 (предварительная);
3. IntelLLVM (icx) версии 1025.3;

## Как мы жили, и живём, до `_Countof`
### Идиома количества элементов массива
В K&R первого издания (1978) был пример получения количества элементов массива:
```c
#define NKEYS  (sizeof (keytab) / sizeof (struct key) )
```

В K&R второго издание (1988) появился практически современный вариант идиомы:
```c
#define NKEYS  (sizeof keytab / sizeof keytab[0])
```

В семействе BSD/..../FreeBSD используется, как идиома в чистом виде, так и в виде множества макросов (`ACPI_ARRAY_LENGTH()`, `ARRAY_LENGTH()`, `ARRAY_SIZE()`, `COUNT()`, `N()`, `NUM_ELEMENTS()`, `nitem()`, `RTE_DIM()`, `UU_NELEM()`) вида:
```c
#define N(a)  (sizeof(a) / sizeof(a[0]))
```
(начиная с FreeBSD 10, после перехода на `clang`, они больше полагаются на расширенные предупреждения о потенциальных неоднозначностях)

В ядре Linux, идиома в чистом виде встречается крайне редко, практически всё, процентов на 99,7% или немного больше, сведено к единому макросу `ARRAY_SIZE()`, который с 2007 года имеет вид:
```c
#define ARRAY_SIZE(arr)  (sizeof(arr) / sizeof((arr)[0]) + __must_be_array(arr))
```

В Visual Studio 2005 был введён шаблон/макрос `_countof()`:
```c++
#if __cplusplus
    template<typename _CountofType, size_t _SizeOfArray>
    char (*_countof_helper(_UNALIGNED _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
    #define _countof(_Array)  (sizeof(*_countof_helper(_Array)) + 0)
#else
    #define _countof(_Array)  (sizeof(_Array) / sizeof(_Array[0]))
#endif
```
### Подводные камни оператора `sizeof`

1. `sizeof` возвращает размер операнда в байтах, но байт байту рознь;
2. `sizeof` иногда вычисляет операнд. а иногда нет;
3. `sizeof` иногда является константой времени компиляции, а иногда нет;
4. Нет гарантий, что `sizeof` не равняется 0.

#### "Размерность" `sizeof`
Оператор `sizeof` возвращает размер своего операнда в байтах, но байт байту - рознь. К примеру, компилятор `clang` с версии 3.0 (2011) имеет ряд предупреждений о неоднозначном использовании оператора `sizeof`: "-Wsizeof-array-argument", "-Wsizeof-array-decay", "-Wsizeof-array-div", "-Wsizeof-pointer-div", "-Wsizeof-pointer-memaccess":
```с
size_t foo(size_t n, int a[static n]) {
    return sizeof(a);  // Непонятно, предупреждение ... [-Wsizeof-array-argument]
}
size_t boo(size_t n, int *a) {
    return sizeof(a);  // Всё понятно, предупреждений нет
}
int main(void) {
    int a[1917];
    printf("%zu\n", sizeof(a)/sizeof(short)); // Непонятно, массив int, а делим на short, предупреждение ... [-Wsizeof-array-div]
    printf("%zu\n", sizeof(a)/2); // Всё понятно, предупреждений нет
}
```
Компилятор `gcc` тоже поддерживает предупреждения такого рода, но для немного меньшего числа случаев. Кроме того, для большинства из них, эти предупреждения, по умолчанию, отключены.
#### `sizeof` не всегда является положительным константным выражением
Все известные компиляторы, которые поддерживают VLA, расширяют C в части возможности существования VLA размера 0 без каких-либо предупреждений или ограничений:
```с
for (size_t n = 0; n < 10; n++) {
    int v[n];
    printf("%zu\n", sizeof v);
}
```
Мало того, большинство компиляторов поддерживают расширения C в части массивов фиксированого размера равного 0, а так же других объектов размера равного 0, как и массивов таких объектов:
```c
int main(void) {
    struct {} s0;
    static_assert(0 == sizeof(s0));
    int a0[] = {};
    static_assert(0 == sizeof(a0));
    struct {} a1917s0[1917];
    static_assert(0 == sizeof(a1917s0));
    struct {} a0s0[0];
    static_assert(0 == sizeof(a0s0));
}
```
### Альтернативы без `sizeof`
