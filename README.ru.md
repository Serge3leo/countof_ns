[![CMake on multiple platforms](https://github.com/Serge3leo/countof_ns/actions/workflows/cmake-multi-platform.yml/badge.svg)](https://github.com/Serge3leo/countof_ns/actions/workflows/cmake-multi-platform.yml)

# Число элементов массива, C23/C++11 переносимая реализация

Макрос `countof_ns(array)` возвращает количество элементов в своем операнде.
Количество элементов определяется типом операнда. Результатом является целое
число. Если количество элементов массива является переменным, операнд
вычисляется, в противном случае операнд не вычисляется, и выражение является
целым константным выражением.

`countof_ns()` это переносимая реализация оператора `_Countf` (макроса
`countof`), определённого в проекте стандарта C2y с небольшими синтаксическими
и семантическим отличиями.

Он реализован средствами стандартов C23/C++11 или с использованием расширений
стандартов C99/C++11, которые поддерживаются большинством компиляторов.
Неполный список совместимых компиляторов: Clang, GNU gcc, Intel (классический
icc), IntelLLVM (icx), MSVC (Visual Studio 2022), LCC (MCST Elbrus), NVHPC
(NVIDIA HPC Compiler), Pelles C, PGI (The Portland Group(?)), SunPro (Oracle
Developer Studio).

## Содержание

- [Введение](#введение)
- [Установка](#установка)
- [Использование](#использование)
- [Обоснование](#обоснование)
- [Участие](#участие)
- [Оговорка](#оговорка)
- [Лицензия](#лицензия)

## Введение

Возможность просто, надёжно и безопасно получить число элементов массива - это
весьма полезная и долгожданная функция, которая позволит сделать код более
компактным, более безопасным и более удобным для сопровождения и/или
рефакторинга, подробности см. [Обоснование](#обоснование).

Синтаксически `countof_ns(array)` - макрос с одним аргументом, который является
выражением типа массива, т.е. поддерживается только один вариант `_Countof
unary-expression`, где выражение взято в скобки. Варианты `_Countof
unary-expression` без скобок и `_Countof ( type-name )` не поддерживаются.

Для массивов, соответствующих стандарту языка C, ограничения и возвращаемое
значение совпадают.  Дополнительно имеется возможность, настройкой макроса,
включить или отключить дополнительное ограничение на постоянство числа
элементов (т.е. потребовать, что бы все возвращаемые значения были целым
константными выражениями или разрешить их вычисление во время выполнения).

Дополнительно макрос `countof_ns(array)` может быть использован в C++ с
результатами идентичными результатам оператора `_Countof unary-expression`.

## Установка

Реализация макроса `countof_ns()` состоит из одного, не имеющего зависимостей,
файла [`include/countof_ns.h`](include/countof_ns.h).  Этот файл можно просто
скопировать в необходимое место на путях поиска заголовочных файлов.

Как альтернативный вариант, можно в вашем cmake проекте использовать
`FetchContent`:

```
include(FetchContent)
FetchContent_Declare(
    CountofNS
    GIT_REPOSITORY https://github.com/Serge3leo/countof_ns.git
    GIT_TAG  71aa5528b84dbdc168a4750e4621a209ae5903c2 # v0.1.0-pre-examples
)
FetchContent_MakeAvailable(CountofNS)
```

Пример использования FetchContent в проекте cmake смотрите:
[`examples/cmake_fetch_content/CMakeLists.txt`](examples/cmake_fetch_content/CMakeLists.txt).

## Примеры и тесты

В основном этот проект состоит из примеров использования и тестов, которые
могут быть запущены. Используется система сборки `cmake`, тесты `ctest`, на
`GitHub Actions` тесты запускаются с генераторами `Unix Makefiles` (`gmake`) и
`Visual Studio 17 2022` (`MSBuild`).

Для ограниченного и упрощённого запуска сборки примеров и тестов:
- [`./examples-build.sh`](./examples-build.sh) - в интерфейсе командной строки
  FreeBSD/Linux/macOS;
- [`examples-build.bat`](./examples-build.bat) - в интерфейсе CMD Windows.

Для `./examples-build.sh` в опциональных аргументах могут быть заданы команды
компиляторов (для некоторых компиляторов, может потребоваться предварительно
установить переменные окружения). Каталог сборки:
`build/<платформа>[_имя_компилятора]`.

А `examples-build.bat` проще всего запускать из Native Tools Command Prompt for
VS. Каталог сборки: `build/<версия VS>`.  Сборки тестов и первоначального
запуска тестов, в этом каталоге остаётся файл решения `countof_ns.sln` в
котором определены "глобальные" цели `ALL_BUILD` и `RUN_TESTS`.  Модифицировать
и повторно запускать можно уже из среды `Visual Studio`.

TODO Предупреждение. У проекта `cmake`/`ctest` по умолчанию, есть особенность,
необходимо сначала собрать `ALL_BUILD` и только потом запускать тесты сборкой
`RUN_TESTS`

### Примерные системные требования к тестам

- cmake 3.25 или выше;
- FreeBSD 14 или выше;
- Linux Debian 12 (Bookworm) или выше;
- Windows 10, Visual Studio 2022 (MSVC 19.44) или выше.

### Простой пример

Исходный код [`examples/examples/short_example.h`](examples/short_example.h).
Переменная `cmake` - `COUNTOF_NS_SHORT_EXAMPLE`, включена по умолчанию. Сборка
и запуск:

```
$ ./examples-build.sh

> examples-build.bat
```

| Цель                           | Комментарий                                                                                                                 |
| ------------------------------ | -------------------------------------------------------------------------------------------------------------------------- |
| `short_example`                | Файл короткого примера.                                                                                                    |
| `short_example.build_fail`     | В норме, файл не должен создаваться, т.к. при сборке определяется `-DEXAMPLE_FAIL` и должна происходить ошибка компиляции. |
| `short_example_cxx`            | Файл короткого примера, собранного C++                                                                                     |
| `short_example_cxx.build_fail` | В норме, файл не должен создаваться, т.к. при сборке определяется `-DEXAMPLE_FAIL` и должна происходить ошибка компиляции. |
### Сложный пример

Исходный код [`examples/examples/long_example.h`](examples/long_example.h).
Переменная `cmake` - `COUNTOF_NS_EXAMPLES`, по умолчанию. Сборка и запуск:

```
$ ./examples-build.sh -- -DCOUNTOF_NS_EXAMPLES=ON

> examples-build.bat -- "-DCOUNTOF_NS_EXAMPLES=ON"
```

| Цель                               | Комментарий                                                                                                                     |
| ---------------------------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| `long_example`                     | Файл короткого примера.                                                                                                         |
| `long_example.build_fail`          | В норме, файл не должен создаваться, т.к. при сборке определяется `-DEXAMPLE_FAIL` и должна происходить ошибка компиляции.      |
| `long_example_с11`                 | Опциональный файл короткого примера, собранного с ключом EXAMPLE_VLA_C11_ENABLE, если компилятор поддерживает VLA.              |
| `long_example_c11.build_fail`      | В норме, файл не должен создаваться, т.к. при сборке определяется `-DEXAMPLE_FAIL` и должна происходить ошибка компиляции.      |
| `long_example_bltn`                | Опциональный файл короткого примера, собранного с ключом EXAMPLE_VLA_BUILTIN_ENABLE, если компилятор поддерживает VLA.          |
| `long_example_bltn.build_fail`     | В норме, файл не должен создаваться, т.к. при сборке определяется `-DEXAMPLE_FAIL` и должна происходить ошибка компиляции.      |
| `long_example_cxx`                 | Файл короткого примера, собранного C++                                                                                          |
| `long_example_cxx.build_fail`      | В норме, файл не должен создаваться, т.к. при сборке определяется `-DEXAMPLE_FAIL` и должна происходить ошибка компиляции.      |
| `long_example_cxx_bltn`            | Опциональный файл кайл короткого примера, собранного C++ с ключом EXAMPLE_VLA_BUILTIN_ENABLE, если компилятор поддерживает VLA. |
| `long_example_cxx_bltn.build_fail` | В норме, файл не должен создаваться, т.к. при сборке определяется `-DEXAMPLE_FAIL` и должна происходить ошибка компиляции.      |



Абзац
за
три
слова

Абзац за две  
строки

Нечто
за одну




### Сложный пример



Простой тест


This module depends upon a knowledge of [Markdown]().

```

```

### Any optional sections

## Использование

### Использование с расширениями C/C++

`countof_ns()` так же применима, как к расширенным массивам нулевой длины, так
и к массивам содержащим расширенные объекты нулевой длины ( [пустые
структуры](https://gcc.gnu.org/onlinedocs/gcc/Empty-Structures.html),
[объединения c массивом неопределённого
размера](https://gcc.gnu.org/onlinedocs/gcc/Flexible-Array-Members-in-Unions.html)
или [структуры с единственным массивом неопределённого
размера](https://gcc.gnu.org/onlinedocs/gcc/Flexible-Array-Members-alone-in-Structures.html)).
У С реализации `countof_ns()` есть одно ограничение:

```
#if !__cplusplus
    size_t a = countof_ns(int[0][0]);  // OK, =0
    size_t b = countof_ns(int[0][5]);  // OK, =0
    size_t c = countof_ns(int[5][0]);  // Compilation error
    int n = 5;
    size_t d = countof_ns(int[n][0]);  // Difference, for VLA of ZLA, return 0
#else
    static_assert(0 == countof_ns(int[0][0]));  // OK, =0
    static_assert(0 == countof_ns(int[0][5]));  // OK, =0
    static_assert(5 == countof_ns(int[5][0]));  // OK, =5
#endif
```

С++ реализация `countof_ns()` выдаёт результаты идентичные `countof()`.

## Обоснование

Во-первых, это компактно. Однако, есть ещё несколько важных причин для
использования `countof_ns()`.

### Подводные камни `sizeof()` в языке C

1. Несоответствие размерностей у числа байт и числа элементов...;

2. `sizeof()` не всегда является константным выражением. Конечно, в простейшем
   случае `const int n = 1; static_assert(0 == sizeof(int[n]));` компилятор
   сообщит об ошибке. Но в более сложных сценариях, компиляция может проходить
   без ошибок или предупреждений. А неопределённое поведение может возникать
   только уже на этапе выполнения кода;

3. `sizeof()` не всегда положителен. Весьма большое число компиляторов, по
   умолчанию поддерживают следующие расширения:
    - `static_assert(0 == sizeof(int[0]));  // C/C++, zero-length arrays`
    - `static_assert(0 == sizeof(struct{}));  // C only, empty structures`
    - `static_assert(0 == sizeof(struct{char fma[];}));  // C/C++, аlone
      flexible array member for structures or unions`
    - `int a[] = {}; static_assert(0 == sizeof(a);  // C/C++, empty initializer
      list`

Даже в случае компактного выражения вида `sizeof(a)/sizeof(*a)` компилятор не
всегда сможет выдать адекватное предупреждение в момент компиляции. А при
отсутствии стандартной функции, иногда, вычисление может оказаться разбросанным
по нескольким операторам, или может быть совмещено с другими вычислениями, что
делает задачу выдачи компилятором, хотя бы, предупреждения ещё более сложной. В
общем, всё это и послужило основанием включения функции `countof()` в проект
стандарта C2y.

### Возможные ошибки при рефакторинге

#### Изменение способа хранения и/или передачи массива

#### Изменение размерностей многомерных массивов

#### Изменение списков инициализации

### Область применения `countof_ns()` в C++

Достаточно давно, начиная с С++17 появилась функция `std::size()`. Собственно
это функция несложная и достаточно просто реализуется с помощью шаблонов C++.
Например, с ещё более давних пор, у MSVC есть её аналог: `_countof()`.

Для проектов только на C++ `std::size()` отличный инструмент, но для смешанных
C/C++ проектов он не всегда удобен. Для смешанных проектов идеально иметь
идентичный инструмент для обоих языков, например, тот же `_countof()` MSVC.

Так же, `std::size()` не очень подходит для компиляторов с поддержкой
расширения `zero-length array`, ввиду того, что реализация `countof()` для
таких массивов работает нормально, а `std::size()` выдаёт ошибку компиляции.

### Массивы VLA и стандарты C99/C11

В языке C... TODO

## Участие

Замечания (Issue), добавления или исправления (PR) - принимаются и
приветствуются.

Небольшое примечание: При редактировании Readme, пожалуйста, придерживайтесь
рекомендаций [standard-readme](https://github.com/RichardLitt/standard-readme).

## Оговорка

Извините, пока документ очень далёк от идеала. TODO

## Лицензия

[BSD-2-Clause © 2025 Сергей Леонтьев (leo@sai.msu.ru).](../LICENSE)
